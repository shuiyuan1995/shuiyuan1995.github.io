{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"3d轮播相册","slug":"3d轮播相册","date":"2019-03-13T04:13:21.000Z","updated":"2019-03-13T04:13:46.985Z","comments":false,"path":"2019/03/13/3d轮播相册/","link":"","permalink":"http://yoursite.com/2019/03/13/3d轮播相册/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"学习es6 Promise笔记","slug":"学习es6-Promise理解","date":"2019-03-04T05:56:41.000Z","updated":"2019-03-12T07:21:38.901Z","comments":false,"path":"2019/03/04/学习es6-Promise理解/","link":"","permalink":"http://yoursite.com/2019/03/04/学习es6-Promise理解/","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 promise简介 用在异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 可以在队列之间传递与操作promise，帮助我们处理队列。 promise产生原因 javascript 包含大量异步操作。 有了node.js之后对异步的依赖进一步加剧了。 无阻塞高并发，是node.js的招牌。 异步操作是其保障。 大量操作依赖回调函数。 异步回调问题： 嵌套层次很深，难以维护。 无法正常使用return 和 throw。 无法正常检索堆栈信息。 多个回调之间难以建立联系。 简单promisenew Promise( //执行器 executor function (resolve, reject) { //一段耗时很长的异步操作 resolve(); //数据处理完成 reject(); //数据处理出错 } ).then(function A() { //成功，下一步 },function B() { //失败，做相应处理 }); promise详解 promise状态 pending：【待定】初始状态。 fulfilled：【实现】操作成功。 rejected：【被否决】操作失败。 promise是一个代理对象，它与原先要进行的操作并无关系。 通过引入一个回调，避免更多回调。 promise状态发生改变，就会触发.then()里的响应函数处理后续步骤。 promise状态一经改变，不会在变。 我们在任何一个地方，生成了一个promise队列之后，我们可以吧它作为一个变量传到其他地方,如果我们的操作是很明显的队列的状态，先进先出的状态，我们就可以在它后面去追叙任意多的.then()，不管它前面的promise是完成了还是没完成队列都会按照固定的顺序去执行，如果没完成就会按照顺序去完成；如果已完成，后面追加的.then()也会得到前面promise返回的值，这就是promise作为队列最重要的特性所在。 console.log('start'); let promise = new Promise(resolve => { setTimeout(() => { console.log('the promise fulfilled'); resolve('hello, world'); }, 1000); }); setTimeout(() => { promise.then(value => { console.log(value) }) }, 3000) 在promise里面，如果你不直接返回一个promise实例，那么它就会默认的去执行下一个环节，即使在里面返回了false也不影响下一步，因为false会直接传递到下一句里面；如果不传值就相当于我们return了一个undefined，任然不影响promise继续往下面去执行。 console.log('here we go'); new Promise(resolve => { setTimeout(() => { resolve('hello'); }, 2000); }).then(value => { console.log(value); console.log('everyone'); (function () { return new Promise(resolve => { setTimeout(() => { console.log('Mr.Laurence'); resolve('Herry Xmas'); },2000); }); }()); return false; }).then(value => { console.log(value + ' world'); }); /*结果： here we go hello everyone false world Mr.Laurence */ Promise会自动捕捉内部异常，并交给rejected响应函数处理。 .then() .then()接收两个函数作为参数，分别代表fulfilled和rejected。 .then()返回一个新的Promise实例，所以他可以链式调用。 当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行。 状态响应函数可以返回新的Promise，或其他值。 如果返回新的Promise，那么下一级.then()会在新Promise状态改变之后执行。 如果返回其他值，则会立刻执行下一级.then()。 .then()里面有.then(),因为.then()返回的还是Promise实例，会等里面的.then()执行完，在执行外面的。 promise常用函数Promise.all() 批量执行，Promise.all([p1,p2,p3,p4,…])用于将多个Promise实例包装成一个新的Promise实例，返回的实例就是普通的Promise。 它接受一个数组作为参数，数组可以是Promise对象，也可以是别的值，只有Promise会等待状态改变。 当所有的子Promise完成，该Promise完成，返回值是全部值的数组。 有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果。 console.log('here we go'); Promise.all([1, 2, 3]) .then(all => { console.log('1: ', all); return Promise.all([function () { console.log('xxxx'); }, 'xxoo', false]); }) .then(all => { console.log('2: ', all); let p1 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P1'); }, 1500); }); let p2 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P2'); }, 1450); }); return Promise.all([p1, p2]); }) .then(all => { console.log('3: ', all); let p1 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P1'); }, 1500); }); let p2 = new Promise((resolve,reject) => { setTimeout(() => { reject('I\\'m P2'); }, 1000); }); let p3 = new Promise((resolve,reject) => { setTimeout(() => { resolve('I\\'m P3'); }, 3000); }); return Promise.all([p1, p2, p3]); }) .then(all => { console.log('all: ', all); }) .catch(err => { console.log('err: ', err); }) /* 结果： here we go 1: [1, 2, 3] 2: [function(), \"xxoo\", false] 3: [\"I'm P1\", \"I'm P2\"] err: I'm P2 */ ###","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}