{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"面试题收集","slug":"面试题收集","date":"2019-08-15T03:29:44.000Z","updated":"2019-08-15T13:42:05.557Z","comments":false,"path":"2019/08/15/面试题收集/","link":"","permalink":"http://yoursite.com/2019/08/15/面试题收集/","excerpt":"","text":"自己收集学习的一些面试题 DOM事件类1.dom事件的级别（事件绑定）1. DOM0: element.onclick = function(){} 2. DOM2: element.addEventListener(&apos;click&apos;,function(){},false) 3. DOM3: element.addEventListener(&apos;keyup&apos;,function(){},false) 2.dom事件模型1. 捕获事件 2. 冒泡时间 3.dom事件流1. 第一阶段：捕获阶段 2. 第二阶段：目标阶段(事件通过捕获到达目标元素) 3. 第三阶段：冒泡阶段(目标元素上传到windows对象) 4.描述dom时间捕获的具体流程1. window =&gt; document =&gt; html =&gt; body =&gt; ... =&gt; 目标元素 5.event对象的常见应用1. event.preventDefault() : 阻止默认行为 2. event.stopPropagation() : 阻止冒泡 3. event.stoplmmediatePropagation() : 如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行。 4. event.currentTarget : 当前被绑定事件的元素 5. event.target : 当前被点击的元素(多用于事件委托) 6.自定义事件1. Event 12345var eve = new Event('custome');ev.addEventListener('custome',function()&#123; console.log('custome');&#125;);ev.dispatchEvent(eve); 2. CustomEvent 12345var eve = new CustomEvent('custome',Objiect);ev.addEventListener('custome',function()&#123; console.log('custome');&#125;);ev.dispatchEvent(eve); 其他1.vueAPP适配是怎么写的，用的什么单位？1. 使用的rem，vw, em 2.get和post有什么区别？1. 缓存：GET 请求能够被缓存，默认的请求方式也是有缓存的，POST请求默认不会缓存 2. 数据量：GET：不同的浏览器和服务器不同，一般限制在2~8K之间，更加常见的是1k以内，POST方法提交的数据比较大，大小靠服务器的设定值限制，PHP默认是2M（具体的话大家以后看后端给的开发文档就行了）。 3. 安全性：GET的所有参数全部包装在URL中，明文显示，且服务器的访问日志会记录，非常不安全，POST的URL中只有资源路径，不包含参数，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全。所有涉及用户隐私的数据都要用POST传输。 3.计算属性和监听器有什么区别？1. watch：监听器 - 监听器监听属性数据发生变化去影响他人 - 自己改变 =&gt; 影响他人 2. computed：计算属性 - 只要 相关属性的数值发生了变化，计算属性会重新计算 - 根据已知的值，得到一个新值 - 别人改变 =&gt; 影响自己 3. 大部分情况下watch和computed几乎没有差别。但如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。 4.v-for渲染列表是key是用来做什么的？1. 用来更高效的更新虚拟dom 2. 使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。 5.数据请求在生命周期哪一个阶段？1. 看实际情况，一般在 created（或beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。 2. 在created的时候，视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素。 3. 而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，（此时document.getelementById 即可生效了）。 6.水平居中有哪几种方法？1. margin: 0 auto; text-align: center; 2. display:flex; 3. 对于父元素和子元素的宽度都确定的情况:父元素display:table-cell,子元素给剩余宽度一半的margin-left. 4. position:absolute 5. 子元素宽度不确定的情况下:margin: 0 auto; text-align: center;width:fit-content; 6. 父元素display:inline-block子元素margin: 0 auto; text-align: center 7. 通过position:relative、float:left和margin-left实现CSS水平居中。 8. 通过隐藏节点+float的方法实现CSS水平居中 9. 通过transform实现CSS水平居中。 7.flex弹性盒模型？8.父盒子中子盒子浮动有什么后果？1. 父盒子没有高度的话就会出现高度坍塌 9.清除浮动有哪些方法？1. 在浮动元素下面添加一个空标签，在这个标签中设置clear：both； 2. 父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度； 3. 伪元素:after,在元素最后定义一个空的内容，然后让该空的内容来清除浮动. 10.定位有哪些属性？相对定位是相对什么定位？1. 绝对定位absolute,相对定位relative，固定定位：fixed 2. 相对与它本身定位 11.行没元素和行内块元素有什么区别？行内块元素在同一行显示时有默认空隙，如何解决？1. 行内元素：设置width和height无效，竖直方向的如padding-top和margin-bottom不会产生边距效果。 2. 行内块元素：让元素具有块级元素和行内元素的特性：既可以设置长宽，可以让padding和margin生效，又可以和其他行内元素并排。 3. 解决默认空隙：父元素设置font-size为0，子元素单独再设置字体大小 12.数组里面有哪些遍历方法？es61. for循环 2. each，foreach循环 3. forof遍历 4. map循环 5. filter遍历 6. every遍历 7. some遍历 8. reduce 9. reduceRight 13.js中的闭包指什么，用let怎么实现1. js中没有块级作用域，只区分函数作用域和全局作用域，用(function(j){})会产生函数级的作用域，形成闭包。 2. let 声明的就是块作用域，和函数级的作用域一样都可以用于形成闭包。 14.js的执行机制1. JS是单线程语言 2. JS的Event Loop是JS的执行机制。 3. 首先判断JS是同步还是异步，同步就进入主进程，异步就进入event table 4. 异步任务在event table中注册函数，当满足触发条件后，被推入event queue 5. 同步任务进入主线程后一直执行，直到主线程空闲时，查看微任务，如果有就将其放到微任务的“事件队列”里，才会去event queue中查看是否有可执行的异步任务，如果有就推入主进程中 15.v-if和v-show的区别是什么？分别的使用场景1. v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏； 2. v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 3. v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； 4. v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 5. 如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 16.vue中插槽的作用？1. 为了将父组件中的子组件模板数据正常显示 17.原生js里继承是怎么实现的，用prototype是怎么实现的1. 原型链继承:将父类的实例作为子类的原型 2. 构造继承:使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 3. 实例继承:为父类实例添加新特性，作为子类实例返回 4. 拷贝继承 5. 组合继承:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 6. 寄生组合继承:通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点. 18.es6里面新增了的类和方法1. class和继承 19.es6新增的继承是怎样实现的1. Class 可以通过 extends 关键字实现继承 20.jq和vue使用起来有什么区别1. vue是通过vue对象将数据和view完全分离开的，对数据操作不在引用相应的DOM对象；主要是操作数据 2. jQuery是使用选择器（$）选取DOM对象，并对其进行赋值、取值、事件绑定等操作；主要是操作DOM 21.vue父子组件怎么传值1. 父组件向子组件传值:props 2. 子组件向父组件传值:$emit 22.vue兄弟组件怎么传值1. 用订阅者模式bus 2. 创建一个Vue的实例，让各个兄弟共用同一个事件机制。 3. 传递数据方，通过一个事件触发bus.$emit(方法名，传递的数据)。 4. 接收数据方，通过mounted(){}触发bus.$on(方法名，function(接收数据的参数){用该组件的数据接收传递过来的数据})，此时函数中的this已经发生了改变，可以使用箭头函数。 23.vue中vuex和axios的使用1. vuex:vuex是一个专门为Vue.js设计的集中式状态管理架构. 2. axios:基于Promise的HTTP请求客户端 24.es6里面var let const区别1. var定义的变量，作用域是整个封闭函数，是全域的；let定义的变量，作用域是在块级或者字块中； 2. 变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）； 3. 只要块级作用域内存在let，它所声明的变量就会绑定在这个区域； 4. let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）。 5. const用来专门声明一个常量，它跟let一样作用于块级作用域，没有变量提升，重复声明会报错，不同的是const声明的常量不可改变，声明时必须初始化（赋值） 25.js垃圾回收机制1. js的垃圾回收机制就是周期性的找出不再使用的变量，然后释放其占用的内存 2. 可达性:就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3D轮播相册","slug":"3d轮播相册","date":"2019-03-13T04:13:21.000Z","updated":"2019-03-13T06:41:57.258Z","comments":false,"path":"2019/03/13/3d轮播相册/","link":"","permalink":"http://yoursite.com/2019/03/13/3d轮播相册/","excerpt":"","text":"项目地址:https://github.com/shuiyuan1995/2019/blob/master/module/src/components/swiper.vue html代码 123456&lt;div class=&quot;swiper&quot; ondragstart=&quot;return false&quot;&gt; &lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt; &lt;img v-for=&quot;(arr, index) in arrs&quot; :key=&quot;index&quot; :src=&quot;arr.img&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt; vue for循环加载数据 数据 123456789101112arrs:[ &#123;img:&apos;img/0.jpeg&apos;&#125;, &#123;img:&apos;img/1.jpeg&apos;&#125;, &#123;img:&apos;img/2.jpeg&apos;&#125;, &#123;img:&apos;img/3.jpg&apos;&#125;, &#123;img:&apos;img/4.jpeg&apos;&#125;, &#123;img:&apos;img/5.jpeg&apos;&#125;, &#123;img:&apos;img/6.jpeg&apos;&#125;, &#123;img:&apos;img/7.jpeg&apos;&#125;, &#123;img:&apos;img/8.jpeg&apos;&#125;, &#123;img:&apos;img/9.jpeg&apos;&#125;,], 需要加载图片数据 css代码 1234567891011121314.swiper perspective 800px.wrap width 133px height 200px margin 150px auto position relative transform-style preserve-3d transform rotateX(-20deg) img width 100% height 100% position absolute transition transform .5s ease stylus预定义css，渲染样式 js逻辑js初始化 因为加载时轮播图有一个展开动画，所以必须在页面加载完成后启动js。 1234// 初始化window.onload = () =&gt; &#123; this.init()&#125; 获取图片元素，数据长度并计算出图片的旋转度数。 循环数组给每一张图片设置旋转角度，轴位移长度，计算出为移动化延迟。 1234567891011121314151617init()&#123; // 获取元素 let oImg = document.getElementsByTagName(&quot;img&quot;); let imgL = this.arrs.length let deg = 360/imgL // 循环设置 for (let i = 0; i &lt; imgL; i++) &#123; // 设置旋转 let countdeg = deg*i; oImg[i].style.transform = `rotateY($&#123;countdeg&#125;deg) translateZ(350px)` // 计算延迟 let delaytime = imgL - i oImg[i].style.transitionDelay=`$&#123;delaytime/10&#125;s` &#125; // 开启拖拽 this.drag()&#125;, js拖拽 鼠标按下时获取并保存鼠标位置。 鼠标移动时，获取并保存每一次移动坐标点，根据移动坐标点与之前保存坐标相减获取差值除以10。 轮播图当前旋转度数加上差值获取旋转角度并设置。 保存当前鼠标坐标值。 鼠标松开后，取消鼠标移动函数 1234567891011121314151617181920212223242526// 拖拽动作drag()&#123; // 鼠标按下 let self = this document.onmousedown = function(e) &#123; // 鼠标点击位置 let oldx = e.clientX let oldy = e.clientY // 鼠标移动 this.onmousemove = e =&gt; &#123; // 移动坐标 let x = e.clientX let y = e.clientY // 旋转度数 self.rotateY += (x - oldx)/10 self.rotateX += (y - oldy)/10 document.getElementById(&apos;wrap&apos;).style.transform = `rotateY($&#123;self.rotateY&#125;deg) rotateX($&#123;self.rotateX&#125;deg)` oldx = x oldy = y &#125; // 鼠标松开 this.onmouseup = () =&gt; &#123; this.onmousemove = null; &#125; &#125;&#125; 额外知识 ondragstart事件 ondragstart 事件在用户开始拖动元素或选择的文本时触发。 为了让元素可拖动，需要使用 HTML5 draggable 属性。 链接和图片默认是可拖动的，不需要 draggable 属性。 1&lt;p draggable=&quot;true&quot; ondragstart=&quot;return false&quot;&gt;禁止拖动!&lt;/p&gt; 在拖放的过程中会触发以下事件： 在拖动目标上触发事件 (源元素): ondragstart - 用户开始拖动元素时触发。 ondrag - 元素正在拖动时触发。 ondragend - 用户完成元素拖动后触发。 释放目标时触发的事件: ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件。 ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件。 ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件。 ondrop - 在一个拖动过程中，释放鼠标键时触发此事件","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"学习es6 Promise笔记","slug":"学习es6-Promise理解","date":"2019-03-04T05:56:41.000Z","updated":"2019-03-12T07:21:38.901Z","comments":false,"path":"2019/03/04/学习es6-Promise理解/","link":"","permalink":"http://yoursite.com/2019/03/04/学习es6-Promise理解/","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 promise简介 用在异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 可以在队列之间传递与操作promise，帮助我们处理队列。 promise产生原因 javascript 包含大量异步操作。 有了node.js之后对异步的依赖进一步加剧了。 无阻塞高并发，是node.js的招牌。 异步操作是其保障。 大量操作依赖回调函数。 异步回调问题： 嵌套层次很深，难以维护。 无法正常使用return 和 throw。 无法正常检索堆栈信息。 多个回调之间难以建立联系。 简单promisenew Promise( //执行器 executor function (resolve, reject) { //一段耗时很长的异步操作 resolve(); //数据处理完成 reject(); //数据处理出错 } ).then(function A() { //成功，下一步 },function B() { //失败，做相应处理 }); promise详解 promise状态 pending：【待定】初始状态。 fulfilled：【实现】操作成功。 rejected：【被否决】操作失败。 promise是一个代理对象，它与原先要进行的操作并无关系。 通过引入一个回调，避免更多回调。 promise状态发生改变，就会触发.then()里的响应函数处理后续步骤。 promise状态一经改变，不会在变。 我们在任何一个地方，生成了一个promise队列之后，我们可以吧它作为一个变量传到其他地方,如果我们的操作是很明显的队列的状态，先进先出的状态，我们就可以在它后面去追叙任意多的.then()，不管它前面的promise是完成了还是没完成队列都会按照固定的顺序去执行，如果没完成就会按照顺序去完成；如果已完成，后面追加的.then()也会得到前面promise返回的值，这就是promise作为队列最重要的特性所在。 console.log('start'); let promise = new Promise(resolve => { setTimeout(() => { console.log('the promise fulfilled'); resolve('hello, world'); }, 1000); }); setTimeout(() => { promise.then(value => { console.log(value) }) }, 3000) 在promise里面，如果你不直接返回一个promise实例，那么它就会默认的去执行下一个环节，即使在里面返回了false也不影响下一步，因为false会直接传递到下一句里面；如果不传值就相当于我们return了一个undefined，任然不影响promise继续往下面去执行。 console.log('here we go'); new Promise(resolve => { setTimeout(() => { resolve('hello'); }, 2000); }).then(value => { console.log(value); console.log('everyone'); (function () { return new Promise(resolve => { setTimeout(() => { console.log('Mr.Laurence'); resolve('Herry Xmas'); },2000); }); }()); return false; }).then(value => { console.log(value + ' world'); }); /*结果： here we go hello everyone false world Mr.Laurence */ Promise会自动捕捉内部异常，并交给rejected响应函数处理。 .then() .then()接收两个函数作为参数，分别代表fulfilled和rejected。 .then()返回一个新的Promise实例，所以他可以链式调用。 当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行。 状态响应函数可以返回新的Promise，或其他值。 如果返回新的Promise，那么下一级.then()会在新Promise状态改变之后执行。 如果返回其他值，则会立刻执行下一级.then()。 .then()里面有.then(),因为.then()返回的还是Promise实例，会等里面的.then()执行完，在执行外面的。 promise常用函数Promise.all() 批量执行，Promise.all([p1,p2,p3,p4,…])用于将多个Promise实例包装成一个新的Promise实例，返回的实例就是普通的Promise。 它接受一个数组作为参数，数组可以是Promise对象，也可以是别的值，只有Promise会等待状态改变。 当所有的子Promise完成，该Promise完成，返回值是全部值的数组。 有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果。 console.log('here we go'); Promise.all([1, 2, 3]) .then(all => { console.log('1: ', all); return Promise.all([function () { console.log('xxxx'); }, 'xxoo', false]); }) .then(all => { console.log('2: ', all); let p1 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P1'); }, 1500); }); let p2 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P2'); }, 1450); }); return Promise.all([p1, p2]); }) .then(all => { console.log('3: ', all); let p1 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P1'); }, 1500); }); let p2 = new Promise((resolve,reject) => { setTimeout(() => { reject('I\\'m P2'); }, 1000); }); let p3 = new Promise((resolve,reject) => { setTimeout(() => { resolve('I\\'m P3'); }, 3000); }); return Promise.all([p1, p2, p3]); }) .then(all => { console.log('all: ', all); }) .catch(err => { console.log('err: ', err); }) /* 结果： here we go 1: [1, 2, 3] 2: [function(), \"xxoo\", false] 3: [\"I'm P1\", \"I'm P2\"] err: I'm P2 */ ###","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}