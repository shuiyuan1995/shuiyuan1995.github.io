{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"面试题收集","slug":"面试题收集","date":"2019-08-15T03:29:44.000Z","updated":"2019-08-15T03:29:44.625Z","comments":false,"path":"2019/08/15/面试题收集/","link":"","permalink":"http://yoursite.com/2019/08/15/面试题收集/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"},{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"3D轮播相册","slug":"3d轮播相册","date":"2019-03-13T04:13:21.000Z","updated":"2019-03-13T06:41:57.258Z","comments":false,"path":"2019/03/13/3d轮播相册/","link":"","permalink":"http://yoursite.com/2019/03/13/3d轮播相册/","excerpt":"","text":"项目地址:https://github.com/shuiyuan1995/2019/blob/master/module/src/components/swiper.vue html代码 123456&lt;div class=&quot;swiper&quot; ondragstart=&quot;return false&quot;&gt; &lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt; &lt;img v-for=&quot;(arr, index) in arrs&quot; :key=&quot;index&quot; :src=&quot;arr.img&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt; vue for循环加载数据 数据 123456789101112arrs:[ &#123;img:&apos;img/0.jpeg&apos;&#125;, &#123;img:&apos;img/1.jpeg&apos;&#125;, &#123;img:&apos;img/2.jpeg&apos;&#125;, &#123;img:&apos;img/3.jpg&apos;&#125;, &#123;img:&apos;img/4.jpeg&apos;&#125;, &#123;img:&apos;img/5.jpeg&apos;&#125;, &#123;img:&apos;img/6.jpeg&apos;&#125;, &#123;img:&apos;img/7.jpeg&apos;&#125;, &#123;img:&apos;img/8.jpeg&apos;&#125;, &#123;img:&apos;img/9.jpeg&apos;&#125;,], 需要加载图片数据 css代码 1234567891011121314.swiper perspective 800px.wrap width 133px height 200px margin 150px auto position relative transform-style preserve-3d transform rotateX(-20deg) img width 100% height 100% position absolute transition transform .5s ease stylus预定义css，渲染样式 js逻辑js初始化 因为加载时轮播图有一个展开动画，所以必须在页面加载完成后启动js。 1234// 初始化window.onload = () =&gt; &#123; this.init()&#125; 获取图片元素，数据长度并计算出图片的旋转度数。 循环数组给每一张图片设置旋转角度，轴位移长度，计算出为移动化延迟。 1234567891011121314151617init()&#123; // 获取元素 let oImg = document.getElementsByTagName(&quot;img&quot;); let imgL = this.arrs.length let deg = 360/imgL // 循环设置 for (let i = 0; i &lt; imgL; i++) &#123; // 设置旋转 let countdeg = deg*i; oImg[i].style.transform = `rotateY($&#123;countdeg&#125;deg) translateZ(350px)` // 计算延迟 let delaytime = imgL - i oImg[i].style.transitionDelay=`$&#123;delaytime/10&#125;s` &#125; // 开启拖拽 this.drag()&#125;, js拖拽 鼠标按下时获取并保存鼠标位置。 鼠标移动时，获取并保存每一次移动坐标点，根据移动坐标点与之前保存坐标相减获取差值除以10。 轮播图当前旋转度数加上差值获取旋转角度并设置。 保存当前鼠标坐标值。 鼠标松开后，取消鼠标移动函数 1234567891011121314151617181920212223242526// 拖拽动作drag()&#123; // 鼠标按下 let self = this document.onmousedown = function(e) &#123; // 鼠标点击位置 let oldx = e.clientX let oldy = e.clientY // 鼠标移动 this.onmousemove = e =&gt; &#123; // 移动坐标 let x = e.clientX let y = e.clientY // 旋转度数 self.rotateY += (x - oldx)/10 self.rotateX += (y - oldy)/10 document.getElementById(&apos;wrap&apos;).style.transform = `rotateY($&#123;self.rotateY&#125;deg) rotateX($&#123;self.rotateX&#125;deg)` oldx = x oldy = y &#125; // 鼠标松开 this.onmouseup = () =&gt; &#123; this.onmousemove = null; &#125; &#125;&#125; 额外知识 ondragstart事件 ondragstart 事件在用户开始拖动元素或选择的文本时触发。 为了让元素可拖动，需要使用 HTML5 draggable 属性。 链接和图片默认是可拖动的，不需要 draggable 属性。 1&lt;p draggable=&quot;true&quot; ondragstart=&quot;return false&quot;&gt;禁止拖动!&lt;/p&gt; 在拖放的过程中会触发以下事件： 在拖动目标上触发事件 (源元素): ondragstart - 用户开始拖动元素时触发。 ondrag - 元素正在拖动时触发。 ondragend - 用户完成元素拖动后触发。 释放目标时触发的事件: ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件。 ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件。 ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件。 ondrop - 在一个拖动过程中，释放鼠标键时触发此事件","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"学习es6 Promise笔记","slug":"学习es6-Promise理解","date":"2019-03-04T05:56:41.000Z","updated":"2019-03-12T07:21:38.901Z","comments":false,"path":"2019/03/04/学习es6-Promise理解/","link":"","permalink":"http://yoursite.com/2019/03/04/学习es6-Promise理解/","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 promise简介 用在异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 可以在队列之间传递与操作promise，帮助我们处理队列。 promise产生原因 javascript 包含大量异步操作。 有了node.js之后对异步的依赖进一步加剧了。 无阻塞高并发，是node.js的招牌。 异步操作是其保障。 大量操作依赖回调函数。 异步回调问题： 嵌套层次很深，难以维护。 无法正常使用return 和 throw。 无法正常检索堆栈信息。 多个回调之间难以建立联系。 简单promisenew Promise( //执行器 executor function (resolve, reject) { //一段耗时很长的异步操作 resolve(); //数据处理完成 reject(); //数据处理出错 } ).then(function A() { //成功，下一步 },function B() { //失败，做相应处理 }); promise详解 promise状态 pending：【待定】初始状态。 fulfilled：【实现】操作成功。 rejected：【被否决】操作失败。 promise是一个代理对象，它与原先要进行的操作并无关系。 通过引入一个回调，避免更多回调。 promise状态发生改变，就会触发.then()里的响应函数处理后续步骤。 promise状态一经改变，不会在变。 我们在任何一个地方，生成了一个promise队列之后，我们可以吧它作为一个变量传到其他地方,如果我们的操作是很明显的队列的状态，先进先出的状态，我们就可以在它后面去追叙任意多的.then()，不管它前面的promise是完成了还是没完成队列都会按照固定的顺序去执行，如果没完成就会按照顺序去完成；如果已完成，后面追加的.then()也会得到前面promise返回的值，这就是promise作为队列最重要的特性所在。 console.log('start'); let promise = new Promise(resolve => { setTimeout(() => { console.log('the promise fulfilled'); resolve('hello, world'); }, 1000); }); setTimeout(() => { promise.then(value => { console.log(value) }) }, 3000) 在promise里面，如果你不直接返回一个promise实例，那么它就会默认的去执行下一个环节，即使在里面返回了false也不影响下一步，因为false会直接传递到下一句里面；如果不传值就相当于我们return了一个undefined，任然不影响promise继续往下面去执行。 console.log('here we go'); new Promise(resolve => { setTimeout(() => { resolve('hello'); }, 2000); }).then(value => { console.log(value); console.log('everyone'); (function () { return new Promise(resolve => { setTimeout(() => { console.log('Mr.Laurence'); resolve('Herry Xmas'); },2000); }); }()); return false; }).then(value => { console.log(value + ' world'); }); /*结果： here we go hello everyone false world Mr.Laurence */ Promise会自动捕捉内部异常，并交给rejected响应函数处理。 .then() .then()接收两个函数作为参数，分别代表fulfilled和rejected。 .then()返回一个新的Promise实例，所以他可以链式调用。 当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行。 状态响应函数可以返回新的Promise，或其他值。 如果返回新的Promise，那么下一级.then()会在新Promise状态改变之后执行。 如果返回其他值，则会立刻执行下一级.then()。 .then()里面有.then(),因为.then()返回的还是Promise实例，会等里面的.then()执行完，在执行外面的。 promise常用函数Promise.all() 批量执行，Promise.all([p1,p2,p3,p4,…])用于将多个Promise实例包装成一个新的Promise实例，返回的实例就是普通的Promise。 它接受一个数组作为参数，数组可以是Promise对象，也可以是别的值，只有Promise会等待状态改变。 当所有的子Promise完成，该Promise完成，返回值是全部值的数组。 有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果。 console.log('here we go'); Promise.all([1, 2, 3]) .then(all => { console.log('1: ', all); return Promise.all([function () { console.log('xxxx'); }, 'xxoo', false]); }) .then(all => { console.log('2: ', all); let p1 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P1'); }, 1500); }); let p2 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P2'); }, 1450); }); return Promise.all([p1, p2]); }) .then(all => { console.log('3: ', all); let p1 = new Promise(resolve => { setTimeout(() => { resolve('I\\'m P1'); }, 1500); }); let p2 = new Promise((resolve,reject) => { setTimeout(() => { reject('I\\'m P2'); }, 1000); }); let p3 = new Promise((resolve,reject) => { setTimeout(() => { resolve('I\\'m P3'); }, 3000); }); return Promise.all([p1, p2, p3]); }) .then(all => { console.log('all: ', all); }) .catch(err => { console.log('err: ', err); }) /* 结果： here we go 1: [1, 2, 3] 2: [function(), \"xxoo\", false] 3: [\"I'm P1\", \"I'm P2\"] err: I'm P2 */ ###","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}